//
// Created by Maitreya Limkar on 30-08-2025.
//

#include "postprocess.hpp"
#include <filesystem>
#include <fstream>
#include <stdexcept>
#include <iomanip>
#include <cmath>

using std::string; using std::vector;

namespace vtkpp {

// Common VTK type ids (no VTK lib required)
constexpr int VTK_VERTEX                   = 1;
constexpr int VTK_LINE                     = 3;
constexpr int VTK_TRIANGLE                 = 5;
constexpr int VTK_QUAD                     = 9;
constexpr int VTK_TETRA                    = 10;
constexpr int VTK_HEXAHEDRON               = 12;
constexpr int VTK_QUADRATIC_EDGE           = 21;
constexpr int VTK_QUADRATIC_TRIANGLE       = 22;
constexpr int VTK_QUADRATIC_QUAD           = 23; // 8-noded serendipity
constexpr int VTK_QUADRATIC_TETRA          = 24;
constexpr int VTK_QUADRATIC_HEXAHEDRON     = 25; // 20-noded serendipity
constexpr int VTK_BIQUADRATIC_QUAD         = 28; // full 9-noded
constexpr int VTK_TRIQUADRATIC_HEXAHEDRON  = 29; // full 27-noded

static inline int vtk_cell_type_from_pd_npe(int PD, int NPE) {
  // 1D
  if (PD==1 && NPE==2) return VTK_LINE;
  if (PD==1 && NPE==3) return VTK_QUADRATIC_EDGE;

  // 2D simplices
  if (PD==2 && NPE==3) return VTK_TRIANGLE;
  if (PD==2 && NPE==6) return VTK_QUADRATIC_TRIANGLE;

  // 2D quads
  if (PD==2 && NPE==4) return VTK_QUAD;
  if (PD==2 && NPE==8) return VTK_QUADRATIC_QUAD; // serendipity
  if (PD==2 && NPE==9) return VTK_BIQUADRATIC_QUAD;

  // 3D simplices
  if (PD==3 && NPE==4)   return VTK_TETRA;
  if (PD==3 && NPE==10)  return VTK_QUADRATIC_TETRA;

  // 3D hexes
  if (PD==3 && NPE==8)   return VTK_HEXAHEDRON;
  if (PD==3 && NPE==20)  return VTK_QUADRATIC_HEXAHEDRON;    // serendipity
  if (PD==3 && NPE==27)  return VTK_TRIQUADRATIC_HEXAHEDRON; // full

  throw std::runtime_error("VTK writer: unsupported (PD,NPE) combination.");
}

// ---- .vtk frame writer -----------------------------------------------------
void write_step_vtk(const string& filepath,
                    const vector<Node>& NL,
                    const vector<element>& EL,
                    int PD, int step, double time,
                    const Options& opt)
{
  const int nPts = (int)NL.size();
  const int nEl  = (int)EL.size();
  if (nPts == 0 || nEl == 0) throw std::runtime_error("VTK writer: empty mesh.");

  std::filesystem::create_directories(std::filesystem::path(filepath).parent_path());
  std::ofstream f(filepath);
  if(!f) throw std::runtime_error("Cannot open VTK file: " + filepath);

  // ---- Header & FieldData (TIME/CYCLE) -------------------------------------
  f << "# vtk DataFile Version 3.1\n";
  f << "generated by postprocess.cpp\n";
  f << "ASCII\n";
  f << "DATASET UNSTRUCTURED_GRID\n";
  f << "FIELD FieldData 2\n";
  f << "TIME 1 1 double\n"  << time << "\n";
  f << "CYCLE 1 1 int\n"    << step << "\n";

  // ---- POINTS (pad to 3 components) ----------------------------------------
  f << "POINTS " << nPts << " double\n";
  f.setf(std::ios::scientific);
  for (int i = 0; i < nPts; ++i) {
    const auto& X = NL[i].X;
    const double x = X(0);
    const double y = (PD >= 2 ? X(1) : 0.0);
    const double z = (PD == 3 ? X(2) : 0.0);
    f << x << " " << y << " " << z << "\n";
  }

  // ---- CELLS (per-element NPE; 1-based -> 0-based indices) -----------------
  long long cellsInts = 0;
  for (const auto& e : EL) cellsInts += 1 + (long long)e.NPE1;
  const int nVertexCells = opt.add_vertex_cells ? nPts : 0;
  const long long vertexInts = opt.add_vertex_cells ? (long long)nPts * 2 : 0;

  const int totalCells = nEl + nVertexCells;
  const long long totalInts = cellsInts + vertexInts;

  f << "CELLS " << totalCells << " " << totalInts << "\n";
  for (int e = 0; e < nEl; ++e) {
    const int NPE = EL[e].NPE1;
    f << NPE;
    for (int a = 0; a < NPE; ++a) f << " " << (int(EL[e].NdL1(a)) - 1);
    f << "\n";
  }
  if (opt.add_vertex_cells) {
    for (int i = 0; i < nPts; ++i) f << 1 << " " << i << "\n";
  }

  // ---- CELL_TYPES -----------------------------------------------------------
  f << "CELL_TYPES " << totalCells << "\n";
  for (int e = 0; e < nEl; ++e) {
    f << vtk_cell_type_from_pd_npe(PD, EL[e].NPE1) << "\n";
  }
  if (opt.add_vertex_cells) {
    for (int i = 0; i < nPts; ++i) f << VTK_VERTEX << "\n";
  }

  // ---- POINT_DATA (c, v, optional p, optional GP_* arrays) ------------------
  f << "POINT_DATA " << nPts << "\n";

  // c
  f << "SCALARS c double\nLOOKUP_TABLE default\n";
  for (int i = 0; i < nPts; ++i) f << NL[i].u(0) << "\n";

  // v
  f << "VECTORS v double\n";
  for (int i = 0; i < nPts; ++i) {
    const double vx = (PD >= 1 ? NL[i].u(1) : 0.0);
    const double vy = (PD >= 2 ? NL[i].u(2) : 0.0);
    const double vz = (PD == 3 ? NL[i].u(3) : 0.0);
    f << vx << " " << vy << " " << vz << "\n";
  }

  // p (if present at u(1+PD))
  if (!NL.empty()) {
    const auto need = (Eigen::Index)(2 + PD); // c + v(PD) + p
    if (NL[0].u.size() >= need) {
      f << "SCALARS p double\nLOOKUP_TABLE default\n";
      for (int i = 0; i < nPts; ++i) f << NL[i].u(1 + PD) << "\n";
    }
  }

  // GP_* (if you store Gauss-point values on nodes)
  // Guarded with try/catch in case your Node lacks GP_vals.
  try {
    if (!NL.empty()) {
      const auto ngp = (int)NL[0].GP_vals.size();
      if (ngp > 0) {
        for (int g = 0; g < ngp; ++g) {
          f << "SCALARS GP_" << g << " double\nLOOKUP_TABLE default\n";
          for (int i = 0; i < nPts; ++i) {
            double val = (NL[i].GP_vals.size() == ngp ? NL[i].GP_vals(g) : 0.0);
            f << val << "\n";
          }
        }
      }
    }
  } catch(...) {
    // Node has no GP_vals (or not Eigen-like) â€” ignore silently.
  }
}

// ---- .pvd series writer -----------------------------------------------------
PvdSeries::PvdSeries(const std::string& pvdPath) : path_(pvdPath) {}
PvdSeries::~PvdSeries(){ try{ close(); }catch(...){} }

void PvdSeries::ensure_open_(){
  if (open_) return;
  std::filesystem::create_directories(std::filesystem::path(path_).parent_path());
  std::ofstream f(path_);
  if (!f) throw std::runtime_error("Cannot open PVD file: " + path_);
  f << "<VTKFile type=\"Collection\" version=\"0.1\">\n  <Collection>\n";
  f.close();
  open_ = true;
}

void PvdSeries::add(double time, const std::string& relativeVtkFile){
  ensure_open_();
  std::ofstream f(path_, std::ios::app);
  f << "    <DataSet timestep=\"" << time << "\" group=\"\" part=\"0\" file=\"" << relativeVtkFile << "\"/>\n";
}

void PvdSeries::close(){
  if (!open_) return;
  std::ofstream f(path_, std::ios::app);
  f << "  </Collection>\n</VTKFile>\n";
  open_ = false;
}

} // namespace vtkpp